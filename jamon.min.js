"use strict";{let hiddenClassName="hidden";let listenerIndex=1;const listenerProperty=Symbol("listenerProperty");const cssNumberProperties=new Set(["columnCount","fillOpacity","fontWeight","lineHeight","opacity","order","orphans","widows","zIndex","zoom"]);const dataMap=new Map();const proxyMap=new Map();const EventRegExp={FOCUS:/^(blur|change|focus)$/,FORM:/^(reset|submit)$/,KEYBOARD:/^key(down|press|up)$/,MOUSE:/^(click|dblclick|contextmenu)|(mouse(down|enter|leave|move|out|over|up))$/,POINTER:/^pointer(cancel|down|enter|leave|move|out|over|up)$/,TOUCH:/^touch(cancel|end|move|start)$/};const NodeMethod={PREPEND:0,APPEND:1,BEFORE:2,AFTER:3,REPLACE:4};const ClassListMethod={ADD:"add",REMOVE:"remove",TOGGLE:"toggle"};const Relative={PARENT_ELEMENT:"parentElement",FIRST_ELEMENT_CHILD:"firstElementChild",LAST_ELEMENT_CHILD:"lastElementChild"};const matchMethod=Element.prototype.msMatchesSelector?"msMatchesSelector":"matches";function kebabToCamel(property){return property.replace(/-([a-z])/g,(nothing,match)=>match.toUpperCase())}function isUndefined(reference){return typeof reference==="undefined"}function isString(reference){return typeof reference==="string"}function addRemoveToggleClass(context,className,method){if(isUndefined(className)){throw new ReferenceError();}if(!isString(className)){throw new TypeError();}const classNames=className.split(" ").filter(item=>item.length);if(classNames.length){for(const element of context){if(method!==ClassListMethod.TOGGLE){element.classList[method](...classNames)}else{for(const className of classNames){element.classList.toggle(className)}}}}return context}function getSetProperty(context,property,value){if(isUndefined(value)){return context[0][property]}else if(value!==null){value=String(value);for(const element of context){element[property]=value}}else{for(const element of context){delete element[property]}}return context}function getRelative(context,relative){const relatives=[];for(const element of context){relatives.push(element[relative])}return Jamon.from(relatives)}function insertNode(subject,target,operation,contextIndex){target=target instanceof Jamon?target:Jamon.$(target);const lastIndex=target.length-1;let index=0,subjectIsText=false;if(isString(subject)){subject=document.createTextNode(subject);subjectIsText=true}else{subject=Jamon.$(subject)[0]}if(operation===NodeMethod.BEFORE||operation===NodeMethod.AFTER){for(const element of target){element.parentElement.insertBefore((index++<lastIndex)?subject.cloneNode(true):subject,operation===NodeMethod.BEFORE?element:element.nextSibling);if(subjectIsText&&element.parentNode){element.parentNode.normalize()}}}else if(operation===NodeMethod.PREPEND){for(const element of target){element.insertBefore((index++<lastIndex)?subject.cloneNode(true):subject,element.firstChild);if(subjectIsText){element.normalize()}}}else if(operation===NodeMethod.APPEND){for(const element of target){element.appendChild((index<lastIndex)?subject.cloneNode(true):subject);if(subjectIsText){element.normalize()}}}else if(operation===NodeMethod.REPLACE){for(const element of target){element.parentElement.replaceChild(index<lastIndex?subject.cloneNode(true):subject,element);if(subjectIsText){subject.parentNode.normalize()}}}return arguments[contextIndex]}function getProxyId(listener,selector){return`${listener[listenerProperty]}|${selector}`}function findInElement(element,selector,one){let result,temporaryId=false,id=element.id;const method=one?"querySelector":"querySelectorAll";if(!id){temporaryId=true;id=`jamon-temporary-id`;element.id=id}selector=`#${id}${selector}`;result=element[method](selector);if(temporaryId){element.removeAttribute("id")}return result}class Jamon extends Array{static create(type,attributes){const element=document.createElement(type);if(attributes){for(const attribute of Object.keys(attributes)){element.setAttribute(attribute,attributes[attribute])}}return Jamon.from([element])}static set hiddenClassName(className){if(isString(className)&&className.length){hiddenClassName=className}}static $(selector){let result;if(isUndefined(selector)){result=Jamon.from([])}else if(isString(selector)){let element=document.querySelector(selector);element=element?[element]:[];result=Jamon.from(element)}else if([Node.ELEMENT_NODE,Node.DOCUMENT_NODE,Node.TEXT_NODE].includes(selector.nodeType)){result=Jamon.from([selector])}else if(selector instanceof Jamon){result=selector}else{throw new TypeError();}return result}static $$(selector){let result;if(isUndefined(selector)){result=Jamon.from([])}else if(isString(selector)){result=Jamon.from(document.querySelectorAll(selector))}else if(selector instanceof Jamon){result=selector}else if(selector.constructor===NodeList||selector.constructor===HTMLCollection){result=Jamon.from(selector)}else{throw new TypeError();}return result}findOne(selector){let result;for(const element of this){result=findInElement(element,selector,true);if(result){return Jamon.from([result])}}}findAll(selector){let results=[];for(const element of this){results=results.concat(Array.from(findInElement(element,selector)))}return Jamon.from(new Set(results))}filterBy(selector){const elements=this.filter((element)=>element[matchMethod](selector));return Jamon.from(elements)}addClass(className){return addRemoveToggleClass(this,className,ClassListMethod.ADD)}removeClass(className){return addRemoveToggleClass(this,className,ClassListMethod.REMOVE)}toggleClass(className){return addRemoveToggleClass(this,className,ClassListMethod.TOGGLE)}hasClass(className){return this[0].classList.contains(className)}show(){return addRemoveToggleClass(this,hiddenClassName,ClassListMethod.REMOVE)}hide(){return addRemoveToggleClass(this,hiddenClassName,ClassListMethod.ADD)}toggle(){return addRemoveToggleClass(this,hiddenClassName,ClassListMethod.TOGGLE)}val(value){return getSetProperty(this,"value",value)}html(html){return getSetProperty(this,"innerHTML",html)}text(text){return getSetProperty(this,"textContent",text)}prop(property,value){return getSetProperty(this,property,value)}attr(attribute,value){if(isUndefined(value)){return this[0].getAttribute(attribute)}else if(value!==null){for(const element of this){element.setAttribute(attribute,value)}}else{for(const element of this){element.removeAttribute(attribute)}}return this}css(style,value){if(isString(style)){if(!isUndefined(value)){for(const element of this){element.style[kebabToCamel(style)]=value}return this}else{const property=kebabToCamel(style);value=window.getComputedStyle(this[0])[property];return cssNumberProperties.has(property)?value:parseFloat(value)}}else if(typeof style==="object"){const normalizedStyles=new Map();Object.keys(style).forEach((property)=>{const value=style[property];normalizedStyles.set(kebabToCamel(property),value)});for(const element of this){for(const normalizedStyle of normalizedStyles){element.style[normalizedStyle[0]]=normalizedStyle[1]}}return this}}data(attribute,value){if(isUndefined(value)){const element=this[0],storage=dataMap.get(element);let data;if(storage&&(!isUndefined(storage.get(attribute)))){data=storage.get(attribute)}else{data=element.dataset[attribute]}return data}for(const element of this){dataMap.set(element,(dataMap.get(element)||new Map()).set(attribute,value))}return this}width(){return this[0].getBoundingClientRect().height}height(){return this[0].getBoundingClientRect().width}scrollWidth(){return this[0].scrollWidth}scrollHeight(){return this[0].scrollHeight}offset(){const element=this[0];return{left:element.offsetLeft,top:element.offsetTop}}position(position){const rect=this[0].getBoundingClientRect();if(!position){return{left:rect.left,top:rect.top}}for(const element of this){const offsetParent=element.offsetParent||document.body,parentRect=offsetParent.getBoundingClientRect(),computedStyle=window.getComputedStyle(element),style=element.style,left=position.left,top=position.top;let originalLeft,originalTop;if(computedStyle.position==="static"){originalLeft=element.offsetLeft;originalTop=element.offsetTop;style.position="relative"}else{originalLeft=element.offsetLeft-(parseFloat(computedStyle.left)||0);originalTop=element.offsetTop-(parseFloat(computedStyle.top)||0)}if(!isUndefined(left)){style.left=left-originalLeft-parentRect.left+"px"}if(!isUndefined(top)){style.top=top-originalTop-parentRect.top+"px"}}}scrollLeft(value){return getSetProperty(this,"scrollLeft",value)}scrollTop(value){return getSetProperty(this,"scrollTop",value)}parent(){return getRelative(this,Relative.PARENT_ELEMENT)}firstChild(){return getRelative(this,Relative.FIRST_ELEMENT_CHILD)}lastChild(){return getRelative(this,Relative.LAST_ELEMENT_CHILD)}children(){const children=[];for(const element of this){children.push(...Array.from(element.children))}return new Jamon(children)}contents(){const contents=[];for(const element of this){contents.push(...Array.from(element.childNodes))}return new Jamon(contents)}closest(selector){const closests=[];for(const element of this){closests.push(element.closest(selector))}return new Jamon(closests)}prepend(subject){return insertNode(subject,this,NodeMethod.PREPEND,1)}prependTo(target){return insertNode(this,target,NodeMethod.PREPEND,0)}append(subject){return insertNode(subject,this,NodeMethod.APPEND,1)}appendTo(target){return insertNode(this,target,NodeMethod.APPEND,0)}before(subject){return insertNode(subject,this,NodeMethod.BEFORE,1)}insertBefore(target){return insertNode(this,target,NodeMethod.BEFORE,0)}after(subject){return insertNode(subject,this,NodeMethod.AFTER,1)}insertAfter(target){return insertNode(this,target,NodeMethod.AFTER,0)}replaceWith(subject){return insertNode(subject,this,NodeMethod.REPLACE,1)}replaceAll(target){return insertNode(this,target,NodeMethod.REPLACE,0)}clone(deep){const clones=[];for(const element of this){clones.push(element.cloneNode(deep))}return new Jamon(clones)}remove(){for(const element of this){element.remove();element.parentNode.normalize()}return this}on(events,listener){events=events.split(" ");for(const event of events){for(const element of this){element.addEventListener(event,listener)}}return this}off(events,selector,listener){events=events.split(" ");if(listener){listener=proxyMap.get(getProxyId(listener,selector))}else{listener=selector}for(const event of events){for(const element of this){element.removeEventListener(event,listener)}}return this}delegate(event,selector,listener){const proxy=function(e){const target=e.target;if(target[matchMethod](selector)){listener.call(target,e)}};if(!listener[listenerProperty]){listener[listenerProperty]=listenerIndex++}proxyMap.set(getProxyId(listener,selector),proxy);return this.on(event,proxy)}trigger(event,detail){let type="Event",bubbles=false,cancelable=false;if(!isUndefined(detail)){type="CustomEvent"}else if(EventRegExp.MOUSE.test(event)){type="MouseEvent";bubbles=true;cancelable=true}else if(EventRegExp.FOCUS.test(event)){type="FocusEvent";if(event==="change"){bubbles=true}}else if(EventRegExp.FORM.test(event)){bubbles=true;cancelable=true}else if(EventRegExp.KEYBOARD.test(event)){type="KeyboardEvent";bubbles=true;cancelable=true}else if(EventRegExp.TOUCH.test(event)){type="TouchEvent";bubbles=true;if(event!=="touchcancel"){cancelable=true}}else if(EventRegExp.POINTER.test(event)){let exceptions=["pointerenter","pointerleave"];type="PointerEvent";if(!exceptions.includes(event)){bubbles=true}exceptions.push("pointercancel");if(!exceptions.includes(event)){cancelable=true}}for(const element of this){element.dispatchEvent(new window[type](event,{bubbles,cancelable,detail}))}return this}}window.Jamon=Jamon;if(isUndefined(window.$)&&isUndefined(window.$$)){window.$=Jamon.$;window.$$=Jamon.$$}}
