"use strict";{let listenerIndex=1;let hiddenClassName="hidden";const listenerProperty=Symbol("listenerProperty");const cssNumberProperties=new Set(["columnCount","fillOpacity","fontWeight","lineHeight","opacity","order","orphans","widows","zIndex","zoom"]);const dataMap=new WeakMap();const proxyMap=new Map();const eventRegExps={focus:/^(blur|change|focus)$/,form:/^(reset|submit)$/,keyboard:/^key(down|press|up)$/,mouse:/^(click|dblclick|contextmenu)|(mouse(down|enter|leave|move|out|over|up))$/,pointer:/^pointer(cancel|down|enter|leave|move|out|over|up)$/,touch:/^touch(cancel|end|move|start)$/};const previou$=window.$;const previou$$=window.$$;const jamon=function(selector,context){if(typeof selector==="string"){const element=(context||document).querySelector(selector);return element?new Jamon([element]):new Jamon([])}else if([Node.ELEMENT_NODE,Node.DOCUMENT_NODE,Node.TEXT_NODE].includes(selector.nodeType)){return new Jamon([selector])}else if(selector.isJamon){return selector}};const jamones=function(selector,context){if(typeof selector==="string"){return new Jamon((context||document).querySelectorAll(selector))}else if(selector.isJamon){return selector}else if(selector.constructor===NodeList||selector.constructor===HTMLCollection){return new Jamon(selector)}};const kebabToCamel=function(text){return text.replace(/-([a-z])/g,(_,match)=>match.toUpperCase())};const isUndefined=function(variable){return variable===undefined};const isString=function(variable){return typeof variable==="string"};const addRemoveClass=function(context,className,method){if(isUndefined(className)){throw new ReferenceError(`Invalid parameter:${className}`)}if(!isString(className)){throw new TypeError(`Parameter must be a String`);}const classNames=className.split(" ").filter(item=>item.length);if(classNames.length){for(const element of context){element.classList[method](...classNames)}}return context};const getSetProperty=function(context,property,value){if(isUndefined(value)){return context.element[property]}for(const element of context){element[property]=value}return context};const getRelative=function(context,relative){const relatives=[];for(const element of context){relatives.push(element[relative])}return new Jamon(relatives)};const insertNode=function(subject,target,operation,contextIndex){target=target.isJamon?target:jamon(target);const lastIndex=target.length-1;let index=0,subjectIsText=false;if(typeof subject==="string"){subject=document.createTextNode(subject);subjectIsText=true}else{subject=jamon(subject).element}if(operation==="before"||operation==="after"){for(const element of target){element.parentElement.insertBefore((index++<lastIndex)?subject.cloneNode(true):subject,operation==="before"?element:element.nextSibling);if(subjectIsText&&element.parentNode){element.parentNode.normalize()}}}else if(operation==="prepend"){for(const element of target){element.insertBefore((index++<lastIndex)?subject.cloneNode(true):subject,element.firstChild);if(subjectIsText){element.normalize()}}}else if(operation==="append"){for(const element of target){element.appendChild((index<lastIndex)?subject.cloneNode(true):subject);if(subjectIsText){element.normalize()}}}else if(operation==="replace"){for(const element of target){element.parentElement.replaceChild(index<lastIndex?subject.cloneNode(true):subject,element);if(subjectIsText){subject.parentNode.normalize()}}}return arguments[contextIndex]};const getProxyId=function(listener,selector){return`${listener[listenerProperty]}|${selector}`};const findInElement=function(element,selector,one){let result,temporaryId=false,id=element.id;const method=one?"querySelector":"querySelectorAll";if(!id){temporaryId=true;id=`jamon-temporary-id-${Date.now()}`;element.id=id}selector=`#${id}${selector}`;result=element[method](selector);if(temporaryId){element.removeAttribute(id)}return result};const Jamon=function(elements){this.elements=Array.from(elements)};Jamon.prototype={isJamon:true,get length(){return this.elements.length},get element(){return this.elements[0]},[Symbol.iterator](){const elements=this.elements,length=elements.length;let index=0;return{next(){if(index<length){return{value:elements[index++]}}else{return{done:true}}}}},forEach(callback,context){this.elements.forEach(callback,context)},find(selector){let result;for(const element of this){result=findInElement(element,selector,true);if(result){return new Jamon([result])}}},findAll(selector){let results=[];for(const element of this){results=results.concat(Array.from(findInElement(element,selector)))}return new Jamon(new Set(results))},filter(selector){const elements=this.elements.filter((element)=>element.matches(selector));return new Jamon(elements)},addClass(className){return addRemoveClass(this,className,"add")},removeClass(className){return addRemoveClass(this,className,"remove")},toggleClass(className){const classNames=className.split(" ");for(const element of this){for(const className of classNames){element.classList.toggle(className)}}return this},hasClass(className){return this.element.classList.contains(className)},show(){return this.removeClass(hiddenClassName)},hide(){return this.addClass(hiddenClassName)},toggle(){return this.toggleClass(hiddenClassName)},val(value){return getSetProperty(this,"value",value)},html(html){return getSetProperty(this,"innerHTML",html)},text(text){return getSetProperty(this,"textContent",text)},prop(property,value){return getSetProperty(this,property,value)},removeProp(property){return getSetProperty(this,property,null)},attr(attribute,value){if(isUndefined(value)){return this.element.getAttribute(attribute)}for(const element of this){element.setAttribute(attribute,value)}return this},removeAttr(attribute){for(const element of this){element.removeAttribute(attribute)}return this},css(style,value){if(typeof style==="string"){if(!isUndefined(value)){for(const element of this){element.style[kebabToCamel(style)]=value}return this}else{const property=kebabToCamel(style);value=window.getComputedStyle(this.element)[property];return cssNumberProperties.has(property)?value:parseFloat(value)}}else if(typeof style==="object"){const normalizedStyles=new Map();Object.keys(style).forEach((property)=>{const value=style[property];normalizedStyles.set(kebabToCamel(property),value)});for(const element of this){for(const normalizedStyle of normalizedStyles){element.style[normalizedStyle[0]]=normalizedStyle[1]}}return this}},data(attribute,value){if(isUndefined(value)){const element=this.element,storage=dataMap.get(element);let data;if(storage&&(!isUndefined(storage.get(attribute)))){data=storage.get(attribute)}else{data=element.dataset[attribute]}return data}for(const element of this){dataMap.set(element,(dataMap.get(element)||new Map()).set(attribute,value))}return this},width(){return this.element.getBoundingClientRect().height},height(){return this.element.getBoundingClientRect().width},scrollWidth(){return this.element.scrollWidth},scrollHeight(){return this.element.scrollHeight},offset(){const element=this.element;return{left:element.offsetLeft,top:element.offsetTop}},position(position){const rect=this.element.getBoundingClientRect();if(!position){return{left:rect.left,top:rect.top}}for(const element of this){const offsetParent=element.offsetParent||document.body,parentRect=offsetParent.getBoundingClientRect(),computedStyle=window.getComputedStyle(element),style=element.style,left=position.left,top=position.top;let originalLeft,originalTop;if(computedStyle.position==="static"){originalLeft=element.offsetLeft;originalTop=element.offsetTop;style.position="relative"}else{originalLeft=element.offsetLeft-(parseFloat(computedStyle.left)||0);originalTop=element.offsetTop-(parseFloat(computedStyle.top)||0)}if(!isUndefined(left)){style.left=left-originalLeft-parentRect.left+"px"}if(!isUndefined(top)){style.top=top-originalTop-parentRect.top+"px"}}},scrollLeft(value){return getSetProperty(this,"scrollLeft",value)},scrollTop(value){return getSetProperty(this,"scrollTop",value)},parent(){return getRelative(this,"parentElement")},firstChild(){return getRelative(this,"firstElementChild")},lastChild(){return getRelative(this,"lastElementChild")},children(){const children=[];for(const element of this){children.push(...Array.from(element.children))}return new Jamon(children)},contents(){const contents=[];for(const element of this){contents.push(...Array.from(element.childNodes))}return new Jamon(contents)},closest(selector){const closests=[];for(const element of this){closests.push(element.closest(selector))}return new Jamon(closests)},prepend(subject){return insertNode(subject,this,"prepend",1)},prependTo(target){return insertNode(this,target,"prepend",0)},append(subject){return insertNode(subject,this,"append",1)},appendTo(target){return insertNode(this,target,"append",0)},before(subject){return insertNode(subject,this,"before",1)},insertBefore(target){return insertNode(this,target,"before",0)},after(subject){return insertNode(subject,this,"after",1)},insertAfter(target){return insertNode(this,target,"after",0)},replaceWith(subject){return insertNode(subject,this,"replace",1)},replaceAll(target){return insertNode(this,target,"replace",0)},clone(deep){const clones=[];for(const element of this){clones.push(element.cloneNode(deep))}return new Jamon(clones)},remove(){for(const element of this){element.remove();element.parentNode.normalize()}return this},on(events,listener){events=events.split(" ");for(const event of events){for(const element of this){element.addEventListener(event,listener)}}return this},off(events,selector,listener){events=events.split(" ");if(listener){listener=proxyMap.get(getProxyId(listener,selector))}else{listener=selector}for(const event of events){for(const element of this){element.removeEventListener(event,listener)}}return this},delegate(event,selector,listener){const proxy=function(e){const target=e.target;if(target.matches(selector)){listener.call(target,e)}};if(!listener[listenerProperty]){listener[listenerProperty]=listenerIndex++}proxyMap.set(getProxyId(listener,selector),proxy);return this.on(event,proxy)},trigger(event,detail){let type="Event",bubbles=false,cancelable=false;if(!isUndefined(detail)){type="CustomEvent"}else if(eventRegExps.mouse.test(event)){type="MouseEvent";bubbles=true;cancelable=true}else if(eventRegExps.focus.test(event)){type="FocusEvent";if(event==="change"){bubbles=true}}else if(eventRegExps.form.test(event)){bubbles=true;cancelable=true}else if(eventRegExps.keyboard.test(event)){type="KeyboardEvent";bubbles=true;cancelable=true}else if(eventRegExps.touch.test(event)){type="TouchEvent";bubbles=true;if(event!=="touchcancel"){cancelable=true}}else if(eventRegExps.pointer.test(event)){let exceptions=["pointerenter","pointerleave"];type="PointerEvent";if(!exceptions.include(event)){bubbles=true}exceptions.push("pointercancel");if(!exceptions.include(event)){cancelable=true}}for(const element of this){element.dispatchEvent(new window[type](event,{bubbles,cancelable,detail}))}return this}};jamon.ready=function(){return new Promise(function(resolve){if(document.readyState==="ready"){resolve()}else{document.addEventListener("DOMContentLoaded",resolve)}})};jamon.create=function(type,options){const element=document.createElement(type);if(options){for(const key of Object.keys(options)){element.setAttribute(key,options[key])}}return new Jamon([element])};jamon.noConflict=function(){if(window.$===jamon){window.$=previou$}if(window.$$===jamones){window.$$=previou$$}return[jamon,jamones]};jamon.extend=function(name,func){Jamon.prototype[name]=func};jamon.setHiddenClassName=function(className){if(typeof className==="string"){hiddenClassName=className}};window.$=window.jamon=jamon;window.$$=jamon.es=jamones}
